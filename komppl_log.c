/*
 ***** Н А Ч А Л О   файла компилятора с языка высокого уровня
 */

/*
 ***** Б л о к  об'явлений макроопределений
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

void printNear(int I,int R,char* str)
{
    int start=I-R;
    int end=I+R;
    if(start<0){start=0;}
    int len=strlen(str);
    if(end>len){end=len;}
    for(;start<end;start++)
    {
        printf("%c",str[start]);
    }
    printf("\n");
}

/* п р е д е л ь н ы е    */
/* размеры:               */
#define MAXNISXTXT 50                             /* - исходного текста;    */
#define NSINT     301                             /* - табл.синтакс.правил; */
#define NCEL       20                             /* - стека целей;         */
#define NDST      500                             /* - стека достижений;    */
#define NVXOD      56                             /* - табл.входов;         */
#define NSTROKA   200                             /* - строки плотн.текста; */
#define NNETRM     20                             /* - списка нетерминалов; */
#define MAXLTXT    50                             /* - выходного текста;    */
#define MAXFORMT   30                             /* - форматированного ин- */
/* терпретируемого  фраг- */
/* мента исх.текста;      */
#define NSYM      100                             /* - таблицы имен и меток */

/*
 ***** Б а з а  данных компилятора
 */

/*
 ***** Б л о к  об'явления массива с исходным текстом
 */

int NISXTXT;                                      /* длина массива          */
char ISXTXT [MAXNISXTXT][80];                     /* тело массива           */

/*
 ***** Б л о к  об'явления рабочих переменных
 */

int I1,I2,I3,I4;                                  /* счетчики циклов        */

char PREDSYM = ' ';                               /*последний обработанный  */
/*символ в уплотненном    */
/*исходном тексте         */

char STROKA [ NSTROKA ];                          /*место хранения уплотнен-*/
/*ного исходного текста   */

int I,J,K,L;                                      /*текущие индексы соответ-*/
/*ственно в:              */
/* - уплотненном тексте;  */
/* - табл.грамм.правил;   */
/* - стеке поставленных   */
/*целей;                  */
/* - стеке достигнутых    */
/*целей;                  */

union                                             /*шаблон для генерации    */
{                                                 /*записи выходного файла  */
    char BUFCARD [80];                        /*на АССЕМБЛЕРЕ IBM 370   */
    struct
    {
        char METKA   [8];
        char PROB1;
        char OPERAC  [5];
        char PROB2;
        char OPERAND [1];
        char PROB3;
        char COMM    [52];
    } _BUFCARD;
} ASS_CARD;

char ASSTXT [ MAXLTXT ][80];                      /*массив для хранения     */
/*выходного текста на     */
/*АССЕМБЛЕРЕ IBM 370      */

int IASSTXT;                                      /*индекс выходного массива*/

char FORMT [MAXFORMT] [9];                        /*массив для форматирован-*/
/*ного  (в виде последова-*/
/*тельности 9-ти позицион-*/
/*ных строк-лексем) пред- */
/*ставления интерпретиру- */
/*емого фрагмента исходно-*/
/*го плотного текста      */

int IFORMT;                                       /*индекс форматированного */
/*массива                 */
/*
 ***** Б л о к  об'явления таблиц базы данных
 */

/*
 ***** Т а б л и ц а, используемая как магазин (стек) достижений
 */

struct
{
    char DST1 [ 4 ];
    int DST2;
    int DST3;
    int DST4;
    int DST5;
} DST [ NDST ];

/*
 ***** Т а б л и ц а, используемая как магазин (стек) целей
 */

struct
{
    char CEL1 [ 4 ];
    int CEL2;
    int CEL3;
} CEL [ NCEL ];

/*
 ***** Т а б л и ц а, синтаксических правил, записанных в форме распознавания,
 ***** сгруппированных в "кусты" и представленных в виде двухнапрвленного
 ***** списка с альтернативными разветвлениями
 */

struct
{
    int POSL;
    int PRED;
    char DER[4];
    int ALT;
} SINT [ NSINT ] =

/*   __________ _________ _______ _______ ______  

    |  NN      :    посл : пред  :  дер  : альт |  

    |__________:_________:_______:_______:______|                          */  

{  

 {/*.    0     .*/    -1 ,    -1 , "***" ,   -1 },  

  /*                                               вход с символа - 0      */  

 {/*.    1     .*/     2 ,     0 , "0  " ,    0 },  

 {/*.    2     .*/     3 ,     1 , "CIF" ,    0 },  

 {/*.    3     .*/     0 ,     2 , "*  " ,    0 },  

  /*                                               вход с символа - 1      */  

 {/*.    4     .*/     5 ,     0 , "1  " ,    0 },  

 {/*.    5     .*/     6 ,     4 , "CIF" ,    7 },  

 {/*.    6     .*/     0 ,     5 , "*  " ,    0 },  

  

 {/*.    7     .*/     8 ,     4 , "MAN" ,    0 },  

 {/*.    8     .*/     0 ,     7 , "*  " ,    0 },  

  /*                                               вход с символа - 2      */  

 {/*.    9     .*/    10 ,     0 , "2  " ,    0 },  

 {/*.   10     .*/    11 ,     9 , "CIF" ,    0 },  

 {/*.   11     .*/     0 ,    10 , "*  " ,    0 },  

  /*                                               вход с символа - 3      */  

 {/*.   12     .*/    13 ,     0 , "3  " ,    0 },  

 {/*.   13     .*/    14 ,    12 , "CIF" ,    0 },  

 {/*.   14     .*/     0 ,    13 , "*  " ,    0 },  

  /*                                               вход с символа - 4      */  

 {/*.   15     .*/    16 ,     0 , "4  " ,    0 },  

 {/*.   16     .*/    17 ,    15 , "CIF" ,    0 },  

 {/*.   17     .*/     0 ,    16 , "*  " ,    0 },  

  /*                                               вход с символа - 5      */  

 {/*.   18     .*/    19 ,     0 , "5  " ,    0 },  

 {/*.   19     .*/    20 ,    18 , "CIF" ,    0 },  

 {/*.   20     .*/     0 ,    19 , "*  " ,    0 },  

  /*                                               вход с символа - 6      */  

 {/*.   21     .*/    22 ,     0 , "6  " ,    0 },  

 {/*.   22     .*/    23 ,    21 , "CIF" ,    0 },  

 {/*.   23     .*/     0 ,    22 , "*  " ,    0 },  

  /*                                               вход с символа - 7      */  

 {/*.   24     .*/    25 ,     0 , "7  " ,    0 },  

 {/*.   25     .*/    26 ,    24 , "CIF" ,    0 },  

 {/*.   26     .*/     0 ,    25 , "*  " ,    0 },  

  /*                                               вход с символа - 8      */  

 {/*.   27     .*/    28 ,     0 , "8  " ,    0 },  

 {/*.   28     .*/    29 ,    27 , "CIF" ,    0 },  

 {/*.   29     .*/     0 ,    28 , "*  " ,    0 },  

  /*                                               вход с символа - 9      */  

 {/*.   30     .*/    31 ,     0 , "9  " ,    0 },  

 {/*.   31     .*/    32 ,    30 , "CIF" ,    0 },  

 {/*.   32     .*/     0 ,    31 , "*  " ,    0 },  

  /*                                               вход с символа - A      */  

 {/*.   33     .*/    34 ,     0 , "A  " ,    0 },  

 {/*.   34     .*/    35 ,    33 , "BUK" ,    0 },  

 {/*.   35     .*/     0 ,    34 , "*  " ,    0 },  

  /*                                               вход с символа - B      */  

 {/*.   36     .*/    37 ,     0 , "B  " ,    0 },  

 {/*.   37     .*/    38 ,    36 , "BUK" ,    0 },  

 {/*.   38     .*/     0 ,    37 , "*  " ,    0 },  

  /*                                               вход с символа - C      */  

 {/*.   39     .*/    40 ,     0 , "C  " ,    0 },  

 {/*.   40     .*/    41 ,    39 , "BUK" ,    0 },  

 {/*.   41     .*/     0 ,    40 , "*  " ,    0 },  

  /*                                               вход с символа - D      */  

 {/*.   42     .*/    43 ,     0 , "D  " ,    0 },  

 {/*.   43     .*/    44 ,    42 , "BUK" ,   45 },  

 {/*.   44     .*/     0 ,    43 , "*  " ,    0 },  

  

{/*.   45     .*/    46 ,    42 , "C  " ,    0 },  

 {/*.   46     .*/    47 ,    45 , "L  " ,    0 },  

 {/*.   47     .*/    48 ,    46 , "   " ,    0 },  

 {/*.   48     .*/    49 ,    47 , "IDE" ,    0 },  

 {/*.   49     .*/    50 ,    48 , "   " ,    0 },   

 {/*.   50     .*/    51 ,    49 , "B  " ,  222 },  

 {/*.   51     .*/    52 ,    50 , "I  " ,    0 },  

 {/*.   52     .*/    53 ,    51 , "N  " ,    0 },  

 {/*.   53     .*/    54 ,    52 , "   " ,    0 },  

 {/*.   54     .*/    55 ,    53 , "F  " ,    0 },  

 {/*.   55     .*/    56 ,    54 , "I  " ,    0 },  

 {/*.   56     .*/    57 ,    55 , "X  " ,    0 },  

 {/*.   57     .*/    58 ,    56 , "E  " ,    0 },  

 {/*.   58     .*/    59 ,    57 , "D  " ,    0 },  

 {/*.   59     .*/    60 ,    58 , ";  " ,    62 },  

{/*.   60     .*/    61 ,    59 , "ODC" ,    0 },  

 {/*.   61     .*/     0 ,    60 , "*  " ,    0 },  

  

{/*. 62 .*/ 63 , 58 , " " , 0 },  

{/*.   63     .*/    64 ,    62 , "(  " ,    201 },  

 {/*.   64     .*/    65 ,    63 , "RZR" ,    0 },  

 {/*.   65     .*/    66 ,    64 , ")  " ,    0 },  

 {/*.   66     .*/    67 ,    65 , ";  " ,   211 },  

 {/*.   67     .*/    68 ,    66 , "ODC" ,    0 },  

 {/*.   68     .*/     0 ,    67 , "*  " ,    0 },  

  

/*                                               вход с символа - E      */  

{/*.   69     .*/    70 ,     0 , "E  " ,    0 },  

 {/*.   70     .*/    71 ,    69, "N  " ,   77 },  

 {/*.   71     .*/    72 ,    70 , "D  " ,    0 },  

 {/*.   72     .*/    73 ,    71 , "   " ,    0 },  

 {/*.   73     .*/    74 ,    72 , "IPR" ,    0 },  

 {/*.   74     .*/    75 ,    73 , ";  " ,    0 },  

 {/*.   75     .*/    76 ,    74 , "OEN" ,    0 },  

 {/*.   76     .*/     0 ,    75, "*  " ,    0 },  

  

 {/*.   77     .*/    78,    69 , "BUK" ,    0 },  

 {/*.   78     .*/     0 ,    77 , "*  " ,    0 },  

  

  /*                                               вход с символа - M      */  

 {/*.   79     .*/    80,     0 , "M  " ,    0 },  

 {/*.   80     .*/    81 ,    79 , "BUK" ,    0 },  

 {/*.   81     .*/     0 ,    80 , "*  " ,    0 },  

  /*                                               вход с символа - P      */  

 {/*.   82     .*/    83 ,     0 , "P  " ,    0 },  

 {/*.   83     .*/    84 ,    82 , "BUK" ,    0 },  

 {/*.   84     .*/     0 ,    83 , "*  " ,    0 },  

  /*                                               вход с символа - X      */  

 {/*.   85     .*/    86 ,     0 , "X  " ,    0 },  

 {/*.   86     .*/    87 ,    85 , "BUK" ,    0 },  

 {/*.   87     .*/     0 ,    86 , "*  " ,    0 },  

  /*                                               вход с символа - BUK    */  

 {/*.   88     .*/    89 ,     0 , "BUK" ,    0 },  

 {/*.   89     .*/    90 ,    88 , "IDE" ,    0 },  

 {/*.    90     .*/     0 ,    89 , "*  " ,    0 },  

  /*                                               вход с символа - IDE    */  

{/*. 91 .*/ 92, 0, "IDE", 0},  

{/*. 92  .*/ 93, 91, "BUK", 95},  

{/*. 93 .*/ 94, 92, "IDE", 0},  

{/*. 94 .*/ 0, 93, "* ", 0},  

  

{/*. 95 .*/ 96, 91, "CIF", 98},  

{/*. 96 .*/ 97, 95, "IDE", 0},  

{/*. 97 .*/ 0, 96, "* ", 0},  

  

{/*. 98 .*/ 99, 91, "IPE", 100},  

{/*. 99 .*/ 0, 98, "* ", 0},  

  

{/*. 100 .*/ 101, 91, "IPR", 0},  

{/*. 101 .*/ 0, 100, "* ", 0},  

  

/*                                                вход с символа - + */  

{/*. 102 .*/ 103, 0 , "+ " , 0 },  

{/*. 103 .*/ 104, 102, "ZNK" , 0 },  

{/*. 104 .*/ 0 , 103 , "* " , 0 },  

  

/*                                                вход с символа - - */  

{/*. 105. */ 106, 0 , "- " , 0 },  

{/*. 106. */ 107, 105 , "ZNK" , 0 },  

{/*. 107.*/ 0 , 106 , "* " , 0 },  

  

/* вход с символа - IPR */  

{/*. 108.*/ 109 , 0 , "IPR" , 0 },  

{/*. 109.*/ 110 , 108 , ": " , 0 },  

{/*. 110 .*/ 111, 109 , "P " , 0 },  

{/*. 111 .*/ 112, 110 , "R " , 0 },  

{/*. 112 .*/ 113 , 111 , "O " , 0 },  

{/*. 113.*/ 114, 112, "C " , 0 },  

{/*. 114 .*/ 115, 113 , " " , 0 },  

{/*. 115 .*/ 116 , 114 , "O " , 0 },  

{/*. 116 .*/ 117 , 115 , "P " , 0 },  

{/*. 117 .*/ 118 , 116 , "T " , 0 },  

{/*. 118 .*/ 119 , 117, "I " , 0 },  

{/*. 119 .*/ 120 , 118 , "O " , 0 },  

{/*. 120 .*/ 121 , 119 , "N " , 0 },  

{/*. 121 .*/ 122 , 120 , "S " , 0 },  

{/*. 122 .*/ 123, 121, "( " , 0 },  

{/*. 123 .*/ 124, 122 , "M " , 0 },  

{/*. 124.*/ 125, 123, "A " , 0 },  

{/*. 125 .*/ 126 , 124, "I " , 0 },  

{/*. 126  .*/ 127 , 125 , "N " , 0 },  

{/*. 127 .*/ 128, 126, ") " , 0 },  

{/*. 128 .*/ 129, 127, "; " , 0 },  

{/*. 129.*/ 130, 128, "OPR" , 0 },  

{/*. 130.*/ 0 , 129, "* " , 0 },  

  

/* вход с символа - CIF */  

{/*. 131 .*/ 132 , 0 , "CIF" , 0 },  

{/*. 132 .*/ 133 , 131 , "RZR" , 134 },  

{/*. 133 .*/ 0 , 132 , "* " , 0 },  

  

{/*. 134 .*/ 135 , 131 , "DCF" , 0},  

{/*. 135.*/ 0 , 134 , "* " , 0 },  

  

/* вход с символа - RZR */  

{/*. 136.*/ 137 , 0 , "RZR" , 0 },  

{/*. 137 .*/ 138 , 136 , "CIF" , 0 },  

{/*. 138 .*/ 139 , 137 , "RZR" , 0 },  

{/*. 139 .*/ 0 , 138 , "* " , 0 },  

  

/* вход с символа - MAN */  

{/*. 140 .*/ 141 , 0 , "MAN" , 0 },  

{/*. 141 .*/ 142 , 140 , "B " , 144 },  

{/*. 142 .*/ 143 , 141 , "LIT" , 0 },  

{/*. 143 .*/ 0 , 142 , "* " , 0 },  

  

{/*. 144 .*/ 145 , 140 , "0 " , 147},  

{/*. 145 .*/ 146 , 144 , "MAN" , 0 },  

{/*. 146 .*/ 0 , 145 , "* " , 0 },  

  

{/*. 147 .*/ 148 , 140 , "1 " , 0 },  

{/*. 148 .*/ 149 , 147 , "MAN" , 0 },  

{/*. 149 .*/ 0 , 148 , "* " , 0 },  

  

/* вход с символа - IPE */  

{/*. 150.*/ 151 , 0 , "IPE" , 0 },  

{/*. 151 .*/ 152 , 150 , "= " , 159 },  

{/*. 152 .*/ 153 , 151 , "AVI" , 156 },  

{/*. 153 .*/ 154 , 152 , "; " , 0 },  

{/*. 154 .*/ 155 , 153 , "OPA" , 0 },  

{/*. 155.*/ 0 , 154 , "* " , 0 },  

  

{/*. 156.*/ 157 , 151, "LOG" , 0},  

{/*. 157.*/ 158 , 156 , "OPL" , 0 },  

{/*. 158 .*/ 0 , 157 , "* " , 0 },  

  

{/*. 159.*/ 160 , 150, "LOP" , 163 },  

{/*. 160 .*/ 161 , 159 , "IPE" , 0 },  

{/*. 161 .*/ 162 , 160 , "LOG" , 0 },  

{/*. 162.*/ 0 , 161 , "* " , 0 },  

  

{/*. 163 .*/ 164 , 150 , "AVI" , 0 },  

{/*. 164 .*/ 0 , 163 , "* " , 0 },  

  

/* вход с символа - LIT */  

{/*. 165 .*/ 166 , 0 , "LIT" , 0 },  

{/*. 166 .*/ 167 , 165 , "AVI" , 0 },  

{/*. 167 .*/ 0 , 166 , "* " , 0 },  

  

/*. вход с символа - AVI */  

{/*. 168 .*/ 169 , 0 , "AVI" , 0 },  

{/*. 169 .*/ 170 , 168 , "ZNK" , 0 },  

{/*. 170 .*/ 171 , 169, "LIT" , 173 },  

{/*. 171 .*/ 172 , 170 , "AVI" , 0 },  

{/*. 172 .*/ 0 , 171 , "* " , 0 },  

  

{/*. 173 .*/ 174 , 169, "IPE" , 0},  

{/*. 174 .*/ 175 , 173 , "AVI" , 0 },  

{/*. 175 .*/ 0 , 174 , "* " , 0 },  

  

/* вход с символа - OPR */  

{/*. 176 .*/ 177 , 0 , "OPR" , 0 },  

{/*. 177 .*/ 178, 176 , "TEL" , 0 },  

{/*. 178 .*/ 179 , 177 , "OEN" , 0 },  

{/*. 179 .*/ 180 , 178 , "PRO" , 0 },  

{/*. 180 .*/ 0 , 179 , "* " , 0 },  

  

/*. вход с символа - ODC */  

{/*. 181 .*/ 182 , 0 , "ODC" , 0 },  

{/*. 182 .*/ 183 , 181 , "TEL" , 0 },  

{/*. 183 .*/ 0 , 182 , "* " , 0 },  

  

/*. вход с символа - TEL */  

{/*. 184 .*/ 185, 0 , "TEL" , 0 },  

{/*. 185 .*/ 186 , 184 , "ODC" , 188 },  

{/*. 186 .*/ 187 , 185 , "TEL" , 0 },  

{/*. 187 .*/ 0 , 186 , "* " , 0 },  

  

{/*. 188 .*/ 189 , 184, "OPA" ,  191},  

{/*. 189 .*/ 190 , 188 , "TEL" , 0 },  

{/*. 190 .*/ 0 , 189 , "* " , 0 },  

  

{/*. 191 .*/ 192 , 184, "OPL" ,  0},  

{/*. 192 .*/ 193 , 191 , "TEL" , 0 },  

{/*. 193 .*/ 0 , 192 , "* " , 0 },  

  

/*. вход с символа - = */  

{/*. 194 .*/ 195 , 0 , "= " , 0 },  

{/*. 195 .*/ 196 , 194 , "LOP" , 0 },  

{/*. 196 .*/ 0 , 195 , "* " , 0 },  

  

/*. вход с символа - DCF */  

{/*. 197 .*/ 198 , 0 , "DCF" , 0 },  

{/*. 198 .*/ 199 , 197 , "CIF" , 0 },  

{/*. 199 .*/ 200 , 198 , "DCF" , 0 },  

{/*. 200 .*/ 0 , 199 , "* " , 0 },  

  

/* Доп. часть объявлений DCL*/  

{/*.   201    .*/    202 ,    62 , "I " ,    0 },   

 {/*.   202    .*/    203,    201 , "N " ,    0 },  

 {/*.   203     .*/    204,    202, "I " ,    0 },  

 {/*.   204     .*/    205 ,    203 , "T " ,    0 },  

 {/*.   205     .*/    206,    204, "( " ,    0 },  

{/*. 206 .*/ 207 , 205, "DCF" , 0 },  

{/*. 207 .*/ 208 , 206 , ") " , 0 },  

{/*. 208 .*/ 209 , 207 , "; " , 0 },  

{/*. 209 .*/ 210 , 208 , "ODC" , 0 },  

{/*. 210 .*/ 0 , 209 , "* " , 0 },  

 

{/*. 211 .*/ 212 , 65 , " " , 0 },  

{/*.   212     .*/    213 , 211 , "I " ,    0 },   

 {/*.   213    .*/    214 , 212 , "N " ,    0 },  

 {/*.   214     .*/    215, 213 , "I " ,    0 },  

 {/*.   215     .*/    216 , 214, "T " ,    0 },  

 {/*.   216     .*/    217 , 215, "( " ,    0 },  

 {/*.   217     .*/    218,  216, "LIT" ,    0 },  

 {/*.   218     .*/    219,  217, ") " ,    0 },  

 {/*.   219     .*/    220,  218, "; " ,    0 },  

 {/*.   220     .*/   221,   219, "ODC" ,    0 },  

{/*.    221     .*/ 0 , 220 , "* " , 0 },  

  

{/*. 222 .*/ 223 , 49 , "D " , 0 }, /*: DEC_FIXED... */  

{/*. 223 .*/ 224 , 222 , "E " , 0 },  

{/*. 224 .*/ 225 , 223 , "C " , 0 },  

{/*. 225 .*/ 226 , 224 , " " , 0 },  

{/*. 226 .*/ 227 , 225 , "F " , 0 },  

{/*. 227 .*/ 228 , 226 , "I " , 0 },  

{/*. 228 .*/ 229 , 227 , "X " , 0 },  

{/*. 229 .*/ 230 , 228 , "E " , 0 },  

{/*. 230 .*/ 231 , 229 , "D " , 0 },  

{/*. 231 .*/ 232 , 230 , " " , 0 },  

{/*. 232 .*/ 233 , 231 , "I " , 0 },  

{/*. 233 .*/ 234 , 232 , "N " , 0 },  

{/*. 234 .*/ 235 , 233 , "I " , 0 },  

{/*. 235 .*/ 236 , 234 , "T " , 0 },  

{/*. 236 .*/ 237 , 235 , "( " , 0 },  

{/*. 237 .*/ 238 , 236 , "DCF" , 0 },  

{/*. 238 .*/ 239 , 237 , ") " , 0 },  

{/*. 239 .*/ 240 , 238 , "; " , 0 },  

{/*. 240 .*/ 241 , 239 , "ODC" , 0 },  

{/*. 241 .*/ 0 , 240 , "* " , 0 },  


{/*. 242 .*/ 243 , 0 , "* " , 0 }, 
{ /*.  243     .*/ 244,   242, "ZNK",    0 },
{ /*.  244     .*/ 0,     243, "*  ",    0 },

};

/*
 ***** Т а б л и ц а  входов в "кусты" ( корней )грамматических правил,
 ***** содержащая тип ( терминальность или нетерминальность ) корневых
 ***** символов
 */

struct
{
    char SYM [4];
    int VX;
    char TYP;
} VXOD [ NVXOD ] =
/*   __________ ___________ _____ ______
 |  NN      |    символ | вход| тип  |
 |__________|___________|_____|______|                                  */

{ 

    { /*.   1     .*/ "AVI", 168, 'N' }, 

    { /*.   2     .*/ "BUK",  88, 'N' }, 

    { /*.   3     .*/ "CIF", 131, 'N' }, 

    { /*.   4     .*/ "IDE",  91, 'N' }, 

    { /*.   5     .*/ "IPE", 150, 'N' }, 

    { /*.   6     .*/ "IPR", 108, 'N' }, 

    { /*.   7     .*/ "LIT", 165, 'N' }, 

    { /*.   8     .*/ "MAN", 140, 'N' }, 

    { /*.   9     .*/ "ODC", 181, 'N' }, 

    { /*.  10     .*/ "OEN",   0, 'N' }, 

    { /*.  11     .*/ "OPA",   0, 'N' }, 

    { /*.  12     .*/ "OPR", 176, 'N' }, 

    { /*.  13     .*/ "PRO",   0, 'N' }, 

    { /*.  14     .*/ "RZR", 136, 'N' }, 

    { /*.  15     .*/ "TEL", 184, 'N' }, 

    { /*.  16     .*/ "ZNK",   0, 'N' }, 

    {/*.   17    .*/ "DCF" , 197, 'N' }, 

    {/*.   18    .*/ "LOP" , 0, 'N' }, 

    {/*.   19    .*/ "LOG" , 0, 'N' }, 

    {/*.   20    .*/ "OPL" , 0, 'N' }, 

    { /*.  21     .*/ "A  ",  33, 'T' }, 

    { /*.  22     .*/ "B  ",  36, 'T' }, 

    { /*.  23     .*/ "C  ",  39, 'T' }, 

    { /*.  24     .*/ "D  ",  42, 'T' }, 

    { /*.  25. */ "E  ",  69, 'T' }, 

    { /*.  26. */ "M  ",  79, 'T' }, 

    { /*.  27. */ "P  ",  82, 'T' }, 

    { /*.  28. */ "X  ",  85, 'T' }, 

    { /*.  29     .*/ "0  ",   1, 'T' }, 

    { /*.  30     .*/ "1  ",   4, 'T' }, 

    { /*.  31    .*/ "2  ",   9, 'T' }, 

    { /*.  32     .*/ "3  ",  12, 'T' }, 

    { /*.  33    .*/ "4  ",  15, 'T' }, 

    { /*.  34     .*/ "5  ",  18, 'T' }, 

    { /*.  35     .*/ "6  ",  21, 'T' }, 

    { /*.  36     .*/ "7  ",  24, 'T' }, 

    { /*.  37     .*/ "8  ",  27, 'T' }, 

    { /*.  38     .*/ "9  ",  30, 'T' }, 

    { /*.  39    .*/ "+  ", 102, 'T' }, 

    { /*.  40    .*/ "-  ", 105, 'T' }, 

    { /*.  41     .*/ ":  ",   0, 'T' }, 

    { /*.  42    .*/ "I  ",   0, 'T' }, 

    { /*.  43    .*/ "R  ",   0, 'T' }, 

    { /*.  44    .*/ "N  ",   0, 'T' }, 

    { /*.  45    .*/ "O  ",   0, 'T' }, 

    { /*.  46     .*/ "T  ",   0, 'T' }, 

    { /*.  47     .*/ "S  ",   0, 'T' }, 

    { /*.  48     .*/ "(  ",   0, 'T' }, 

    { /*.  49    .*/ ")  ",   0, 'T' }, 

    { /*.  50     .*/ "   ",   0, 'T' }, 

    { /*.  51    .*/ ";  ",   0, 'T' }, 

    { /*.  52     .*/ "L  ",   0, 'T' }, 

    { /*.  53     .*/ "F  ",   0, 'T' }, 

    { /*.  54     .*/ "=  ",   0, 'T' }, 

    { /*.  55    .*/ "H  ",   0, 'T' }, 

    { /*.  56    .*/ "*  ", 242, 'T' } 

};

/*
 ***** Т а б л и ц а  матрицы смежности - основа построения матрицы
 ***** преемников
 */

char TPR [ NVXOD ] [ NNETRM ] =
{

    /* 

     __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ 

     |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK:DCF:LOP:LOG:OPL| 

     |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */ 

    { /*AVI*/ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*BUK*/ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0 }, 

    { /*CIF*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,1, 0, 0,0  }, 

    { /*IDE*/ 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*IPE*/ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*IPR*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*LIT*/ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*MAN*/ 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*ODC*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,0, 0, 0,0  }, 

    { /*OEN*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*OPA*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*OPR*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,0, 0, 0,0  }, 

    { /*PRO*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*RZR*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,0, 0, 0,0  }, 

    { /*TEL*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,0, 0, 0,0  }, 

    { /*ZNK*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*DCF*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

{ /*LOP*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

{ /*LOG*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

{ /*OPL*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

 

    /* 

     __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ 

     |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK:DCF: LOP:LOG:OPL| 

     |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */ 

    { /*  A*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  B*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  C*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  D*/ 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  E*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  M*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  P*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  X*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  0*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  1*/ 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  2*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  3*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  4*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  5*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,0, 0, 0,0  }, 

    { /*  6*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,0, 0, 0,0  }, 

    { /*  7*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    /* 

     __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ 

     |       AVI:BUK:CIF:IDE;IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK:DCF: LOP:LOG:OPL| 

     |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */ 

    { /*  8*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  9*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  +*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,0, 0, 0,0  }, 

    { /*  -*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,0, 0, 0,0  }, 

    { /*  :*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  I*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  R*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  N*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  O*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0, 0,0  }, 

    { /*  T*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  S*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  (*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  )*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  ;*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*   */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  L*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    /* 

     __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ 

     |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN;OPA:OPR:PR0:RZR:TEL:ZNK:DCF: LOP:LOG:OPL| 

     |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */ 

    { /*  F*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  =*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 1, 0,0  }, 

    { /*  H*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0,0  }, 

    { /*  **/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,0, 0, 0,0  } 

    /*|_______________________________________________________________________| */ 

}; 

/*..........................................................................*/ 

/*
 ****** Н А Ч А Л О  обработки исходного текста
 */

/*..........................................................................*/

void compress_ISXTXT()                            /* Программа уплотнения   */
/* исходного текста путем */
/* удаления "лишних"      */
/* пробелов, выполняющая  */
/* роль примитивного лек- */
/* сического анализатора  */
{
    printf("compress\n");
    I3 = 0;
    for ( I1 = 0 ; I1 < NISXTXT ; I1++ )
    {
        for ( I2 = 0 ; I2 < 80 ; I2++ ) {
            
            
            if ( ISXTXT [ I1 ][ I2 ] != '\x0' )
            {
                if ( (ISXTXT [ I1 ][ I2 ] == ' ' || ISXTXT [ I1 ][ I2 ] == '\t' || ISXTXT [ I1 ][ I2 ] == '\n') &&
                    ( PREDSYM == ' ' || PREDSYM == '\t' || PREDSYM == '\n' || PREDSYM == ';' ||
                     PREDSYM == ')' || PREDSYM == ':' ||
                     PREDSYM == '('
                     )
                    )
                {
                    PREDSYM = ' ';
                    goto L2;
                }
                
                if
                    (
                     ( ISXTXT [ I1 ][ I2 ] == '+' ||
                      ISXTXT [ I1 ][ I2 ] == '-' ||
                      ISXTXT [ I1 ][ I2 ] == '=' ||
                      ISXTXT [ I1 ][ I2 ] == '(' ||
                      ISXTXT [ I1 ][ I2 ] == ')' ||
                      ISXTXT [ I1 ][ I2 ] == '*'
                      )
                     &&
                     (PREDSYM == ' ' || PREDSYM == '\t' || PREDSYM == '\n')
                     )
                {
                    I3-- ;
                    goto L1;
                }
                
                
                if ( (ISXTXT [ I1 ][ I2 ] == ' ' || ISXTXT [ I1 ][ I2 ] == '\t' || ISXTXT [ I1 ][ I2 ] == '\n') &&
                    ( PREDSYM == '+' || PREDSYM == '-' ||
                     PREDSYM == '=' || PREDSYM == '*'
                     )
                    )
                {
                    goto L2;
                }
                
            L1:
                PREDSYM = ISXTXT [ I1 ][ I2 ];
                if (PREDSYM == '\t') {
                    PREDSYM = ' ';
                }
                STROKA [ I3 ] = PREDSYM;
                //printf("123\n");
                //printf("%s", STROKA[I3]);
                //std::cout<<STROKA[I3];
                I3++ ;
                
            L2:    continue;
            }
            else
                break;
        }
    }
    STROKA [I3] = '\x0';
}

/*..........................................................................*/

void build_TPR ()                                 /* Построение таблицы     */
/* преемников из матрицы  */
/* смежности по алгоритму */
/* Варшалла               */
{
    for ( I1 = 0; I1 < NNETRM; I1++ )
    {
        for ( I2 = 0; I2 < NVXOD; I2++ )
        {
            if ( TPR [ I2 ][ I1 ] & ( I1 != I2 ) )
            {
                for ( I3 = 0; I3 < NNETRM; I3++ )
                    TPR [ I2 ][ I3 ] |= TPR [ I1 ][ I3 ];
            }
        }
    }
}

/*..........................................................................*/

void mcel ( char* T1, int T2, int T3 )            /* программа заполнения   */
{                                                 /* ячейки стека поставлен-*/
    /* ных целей              */
    strcpy ( CEL [ K ].CEL1, T1 );
    CEL [ K ].CEL2 = T2;
    CEL [ K ].CEL3 = T3;
    K++;
    //printf("%s\n", CEL [ K ].CEL1);
}

/*..........................................................................*/

void mdst ( char* T1, int T2, int T3, int T4, int T5 )
{                                                 /* программа заполнения   */
    strcpy ( DST [ L ].DST1, T1 );            /* ячейки стека достигну- */
    DST [ L ].DST2 = T2;                      /* тых целей              */
    DST [ L ].DST3 = T3;
    DST [ L ].DST4 = T4;
    DST [ L ].DST5 = T5;
    printf("%d) %s %d %d %d %d\n", L, DST [ L ].DST1, T2, T3, T4, T5);
    L++;
}


/*..........................................................................*/
/* п р о г р а м м а      */
int numb ( char* T1, int T2 )                     /* вычисления порядкового */
/* номера строки в табл.  */
/* VXOD, соответствующей  */
/* строке-параметру функц.*/
{
    int k;
    
    for ( I1 = 0; I1 < NVXOD; I1++ )
    {
        for ( k = 0; k < T2; k++ )
        {
            if ( (*(T1+k) != VXOD [ I1 ].SYM [k] ) )
                goto numb1;
        }
        if ( (VXOD [ I1 ].SYM [k] == '\x0') ||
            (VXOD [ I1 ].SYM [k] == ' '  )
            )
            return ( I1 );
    numb1:
        continue;
    }
    return -1;
}


/*..........................................................................*/
/*   п р о г р а м м а    */
/*   построения  дерева   */
/*синтаксического разбора,*/
/*выполняющая роль синтак-*/
/*сического анализатора   */
int sint_ANAL ()
{
    I4 = 0;
    
L1:    // Блок начальных установок
    
    K = 0;
    L = 0;
    I = 0;
    J = 1;
    mcel ( "PRO", I, 999 );
    
    if (!TPR [numb ( &STROKA [I], 1 )][numb ( "PRO", 3 )])
        return 1;
    
L2:  // Блок проецирования по выбранной гипотезе
    
    J = VXOD [ numb ( &STROKA [ I ], 1 ) ].VX;
    
L3:
    
    J = SINT [ J ].POSL;
    
L31:
    
    I++;
    
    if ( I > I4 )
        
        
        I4 = I;
    
    if (VXOD [ numb ( SINT [ J ].DER, 3 ) ].TYP == 'T')
    {// Блок обработки терминала
        
        if ( STROKA [ I ] == SINT [ J ].DER [ 0 ] ) {
            printf("T: %c\n", STROKA[ I ]);
            goto L3;
        }
        else
            goto L8; //Проверка на конец грамматического правила
        
    }
    
L4: // Блок обработки нетерминалов
    
    if ( SINT [ SINT [ J ].POSL ].DER [ 0 ] == '*' )
    {
        I--;
        printf("N: %c\n", STROKA[ I ]);
        
        
        if ( !strcmp (SINT [J].DER, CEL [K-1].CEL1 ) )
        {
            mdst ( CEL[K-1].CEL1,CEL[K-1].CEL2,CEL[K-1].CEL3,I,J );
            
            if ( !strcmp( CEL[K-1].CEL1, "PRO" ) ) {
                
                return 0;
            }
            
        L5:
            
            if (TPR [numb (CEL[K-1].CEL1, 3)] [numb (CEL[K-1].CEL1, 3)])
            {
                J = VXOD [ numb ( CEL[K-1].CEL1, 3 ) ].VX;
                goto L3;
            }
            
        L6:
            
            J = CEL[K-1].CEL3;
            K--;
            goto L3;
        }
        
        if (!TPR [numb (SINT[J].DER, 3)] [numb (CEL[K-1].CEL1, 3)])
            goto L9;
        
        mdst ( SINT[J].DER, CEL[K-1].CEL2,0,I,J );
        J = VXOD [numb (SINT[J].DER, 3)].VX;
        goto L3;
    }
    
    if (!TPR [numb (&STROKA [I], 1)] [numb (SINT[J].DER, 3)])
        goto L8;
    
    mcel ( SINT[J].DER,I,J );
    goto L2;
    
L8:  // Блок перебора гипотез
    
    I--;
    
L9:
    
    if (SINT[J].ALT != 0)
    {
        J = SINT[J].ALT;
        goto L31;
    }
    
    J = SINT[J].PRED;
    
    if
        (
	        ( VXOD [numb (SINT[J].DER, 3)].TYP == 'N' )
	        &&
	        ( SINT[J].PRED > 0 )
         )
    {
        mcel (DST[L-1].DST1, DST[L-1].DST2, DST[L-1].DST3);
        //printDST();
        
        
    L10:
        
        J = DST[L-1].DST5;
        L--;
        goto L9;
    }
    
    if
        (
	        ( VXOD [numb (SINT[J].DER, 3)].TYP == 'N' )
	        &&
	        ( SINT[J].PRED == 0 )
         )
    {
        if (!strcmp ( CEL[K-1].CEL1, DST[L-1].DST1 ) )
            goto L6;
        else
            goto L10;
    }
    
    if ( SINT[J].PRED > 0 )
        goto L8;
    
    J = CEL[K-1].CEL3;
    K--;
    //if(J==97)
    //{
    //printNear(I, 10, STROKA);
    //printf("%s\n",SINT[J].DER);
    //}
    if ( J == 999 )
        return 2;
    else
        goto L8;
    
}

/*..........................................................................*/

struct                                            /* таблица имен меток и   */
{                                                 /* переменных, заполняемая*/
    char NAME [8];                            /* на первом проходе се-  */
    char TYPE;                                /* мантического вычисления*/
    char RAZR [5];                            /* и используемая на вто- */
    char INIT [50];                           /* ром проходе семантичес-*/
} SYM [ NSYM ];                                   /* кого вычисления        */

int ISYM = 0;                                     /* текущий индекс таблицы */
/* имен                   */

char NFIL [30]="\x0";                             /* хранилище имени транс- */
/* лируемой программы     */

/*..........................................................................*/
/* п р о г р а м м а      */
/* перевода двоичной      */
/* константы из ASCIIz-ви-*/
/* да во внутреннее пред- */
/* ставление типа long int*/
long int VALUE ( char* s )
{
    long int S;
    unsigned long length = strlen(s);
    if (s[length - 1] == 'B') {
        int i;
        
        i = 0;
        S = 0;
        while ( *(s + i) != 'B' )
            
        {
            
            S <<= 1;
            if ( *(s + i) == '1' )
                S++;
            i++;
        }
    } else {
        S = atoi(s);
    }
    
    return (S);
}



/*..........................................................................*/
/* п р о г р а м м а      */
/* представления фрагмента*/
/* плотного текста в виде */
/* массива 9-ти символьных*/
/* лексем                 */
void FORM ()
{
    int i,j;
    
    for ( IFORMT = 0; IFORMT < MAXFORMT; IFORMT++ )
        memcpy ( FORMT [IFORMT], "\x0\x0\x0\x0\x0\x0\x0\x0\x0", 9 );
    
    IFORMT = 0;
    j = DST [I2].DST2;
    
FORM1:
    
    for ( i = j; i <= DST [I2].DST4+1; i++ )
    {
        if ( STROKA [i] == ':' || STROKA [i] == ' ' ||
            STROKA [i] == '(' || STROKA [i] == ')' ||
            STROKA [i] == ';' || STROKA [i] == '+' ||
            STROKA [i] == '-' || STROKA [i] == '=' ||
            STROKA [i] == '*'
            )
        {
            FORMT [IFORMT] [i-j] = '\x0';
            IFORMT++;
            j = i+1;
            goto FORM1;
        }
        else
            FORMT [IFORMT][i-j] = STROKA [i];
        
    }
    
    return;
}

/*..........................................................................*/
/* п р о г р а м м а      */
void ZKARD ()                                     /* записи очередной сгене-*/
{                                                 /* рированной записи вы-  */
    /* ходного файла в массив */
    /* ASSTXT                 */
    char i;
    memcpy ( ASSTXT [ IASSTXT ],
            ASS_CARD.BUFCARD, 80 );
    printf("%d) %s\n", IASSTXT, ASSTXT [ IASSTXT ]);
    ASSTXT[IASSTXT][79]=0;
    IASSTXT++;
    
    for ( i = 0; i < 79; i++ )
        ASS_CARD.BUFCARD [i] = ' ';
    return;
}

/*..........................................................................*/
/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала AVI на пер-*/
/* вом проходе.   Здесь   */
/* AVI -   "арифм.выраж." */
int AVI1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала BUK на пер-*/
/* вом проходе.   Здесь   */
/* BUK -   "буква"        */
int BUK1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала CIF на пер-*/
/* вом проходе.   Здесь   */
/* CIF -   "цифра"        */
int CIF1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IDE на пер-*/
/* вом проходе.   Здесь   */
/* IDE -   "идентификатор"*/
int IDE1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPE на пер-*/
/* вом проходе.   Здесь   */
/* IPE - "имя переменной" */
int IPE1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPR на пер-*/
/* вом проходе.   Здесь   */
/* IPR -   "имя программы" */
int IPR1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала LIT на пер-*/
/* вом проходе.   Здесь   */
/* LIT -   "литерал"      */
int LIT1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала MAN на пер-*/
/* вом проходе.   Здесь   */
/* MAN -   "мантисса"     */
int MAN1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ODC на пер-*/
/* вом проходе.   Здесь   */
/* ODC - "операт.ПЛ1- DCL"*/
int ODC1 ()
{
    int i;
    FORM ();                                  /* форматирование ПЛ1-опе-*/
    /* ратора DCL             */
    
    for ( i = 0; i < ISYM; i++ )              /* если фиксируем повтор- */
    {                                         /* повторное объявление   */
        if (  !strcmp ( SYM [i].NAME, FORMT [1] ) &&/* второго терма оператора*/
            strlen ( SYM [i].NAME ) == /* DCL, то                */
            strlen ( FORMT [1] )
            )
            return 6;                 /* завершение программы   */
        /* по ошибке              */
    }
    
    strcpy ( SYM [ISYM].NAME, FORMT [1] );    /* при отсутствии повтор- */
    strcpy ( SYM [ISYM].RAZR, FORMT [4] );    /* ного объявления иденти-*/
    /* фикатора запоминаем его*/
    /* вместе с разрядностью в*/
    /* табл.SYM               */
    
    if ( !strcmp ( FORMT [2], "BIN" ) &&      /* если идентификатор оп- */
        !strcmp ( FORMT [3], "FIXED" ) )/* ределен как bin fixed, */
    {
        SYM [ISYM].TYPE = 'B';            /* то устанавливаем тип   */
        /* идентификатора = 'B' и */
        if (!strcmp(FORMT[4], "INIT") || strcmp ( FORMT [5], "INIT" )) {
			strcpy ( SYM [ISYM].RAZR, "15" );
		}
        printf("B ");
        goto ODC11;                       /* идем на продолжение об-*/
        /* работки, а             */
    }
    else  if (!strcmp ( FORMT [2], "DEC" )) //decimal
    {
        //TODO alloc 3 bytes for this variable
        SYM [ISYM].TYPE = 'D';            /* то устанавливаем тип   */
        /* идентификатора = 'B' и */
        printf("P ");
        goto ODC11;
    } else
    { /* иначе                  */
        SYM [ISYM].TYPE = 'U';            /* устанавливаем тип иден-*/
        /* тификатора = 'U'  и    */
        return 2;                         /* завершаем программу    */
        /* по ошибке              */
    }
    
ODC11:
    if ( !strcmp(FORMT[4], "INIT")) {
        //init without range description
        printf(" ");
        strcpy ( SYM [ISYM++].INIT, FORMT [5] ); /* ем в табл. SYM это на- */
        ISYM++;  
    } else {
        //range described before init
        /* если идентификатор     */
        /* имеет начальную иници- */
        printf("else !strcmp(FORMT[4], INIT)");
        if ( !strcmp ( FORMT [5], "INIT" )  )     /* ализацию, то запомина- */
            strcpy ( SYM [ISYM++].INIT, FORMT [6] ); /* ем в табл. SYM это на- */
        /* чальное значение, а    */
        else                                      /* иначе                  */
            strcpy ( SYM [ISYM++].INIT, "0B" ); /* инициализируем иденти- */
        /* фикатор нулем          */
    }
    return 0;                                 /* успешное завешение     */
    /* программы              */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OEN на пер-*/
/* вом проходе.   Здесь   */
/* OEN - "операт.ПЛ1-END" */
int OEN1 ()
{
    char i = 0;
    FORM ();                                  /* форматирование ПЛ1-опе-*/
    /* ратора END             */
    
    for ( i = 0; i < ISYM; i++ )              /* если вторй терм опера- */
    /* тора END записан в табл*/
    {                                         /* SYM и его тип = "P",то:*/
        if ( !strcmp ( SYM [i].NAME, FORMT [1] ) &&
            (SYM [i].TYPE == 'P') &&
            strlen (SYM [i].NAME) ==
            strlen ( FORMT [1] ) )
            return 0;                 /* успешное завершение    */
        /* программы              */
    }
    
    return 1;                                 /* иначе завершение прог- */
    /* раммы по ошибке        */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OPA на пер-*/
/* вом проходе.   Здесь   */
/* OPA - "операт.присваи- */
/* вания арифметический   */
int OPA1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OPR на пер-*/
/* вом проходе.   Здесь   */
/* OPR - "операт.ПЛ1-PROC"*/
int OPR1 ()
{
    FORM ();                                  /* форматируем оператор   */
    /* ПЛ1 PROC               */
    
    strcpy ( SYM [ISYM].NAME, FORMT [0] );    /* перепишем имя ПЛ1-прог-*/
    /* раммы в табл. SYM,     */
    
    SYM [ISYM].TYPE   = 'P';                  /* установим тип этого    */
    /* имени = 'P'            */
    SYM [ISYM++].RAZR [0] = '\x0';            /* установим разрядность  */
    /* равной 0               */
    
    return 0;                                 /* успешное завершение    */
    /* программы              */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала PRO на пер-*/
/* вом проходе.   Здесь   */
/* PRO - "программа"      */

int PRO1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала RZR на пер-*/
/* вом проходе.   Здесь   */
/* RZR - "разрядность"    */

int RZR1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала TEL на пер-*/
/* вом проходе.   Здесь   */
/* TEL - "тело программы" */

int TEL1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на пер-*/
/* вом проходе.   Здесь   */
/* ZNK - "знак операции"  */

int ZNK1 ()
{
    return 0;
}

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на пер-*/
/* вом проходе.   Здесь   */
/* ZNK - "знак операции"  */

int DCF1 ()
{
    return 0;
}

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на пер-*/
/* вом проходе.   Здесь   */
/* ZNK - "знак операции"  */

int LOP1 ()
{
    return 0;
}

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на пер-*/
/* вом проходе.   Здесь   */
/* ZNK - "знак операции"  */

int LOG1 ()
{
    return 0;
}

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на пер-*/
/* вом проходе.   Здесь   */
/* ZNK - "знак операции"  */

int OPL1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала AVI на вто-*/
/* ром проходе.   Здесь   */
/* AVI -   "арифм.выраж." */


int AVI2 ()
{
    char i;
    FORM ();                                  /*форматируем правую часть*/
    /*арифметического ПЛ1-опе-*/
    /*ратора присваивания     */
    
    if ( IFORMT == 1 )                        /* если правая часть одно-*/
    {                                         /* термовая, то:          */
        for ( i = 0; i < ISYM; i++ )      /* ищем этот терм в табли-*/
        {                                 /* це имен  и             */
            if ( !strcmp ( SYM [i].NAME, FORMT [0] )  &&/* если находим, то:      */
                strlen ( SYM [i].NAME ) ==
                strlen ( FORMT [0] )
                )
            {
                if ( SYM [i].TYPE == 'B' ) /* в случае типа=bin fixed*/
                {
                    
                    if ( strcmp ( SYM [i].RAZR, "15" ) /* и разрядности <= 15    */
                        <= 0 )
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, /* формируем код ассембле-*/
                                "LH", 2 ); /* ровской операции LH,   */
                    else
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, /* а при разрядности >15  */
                                "L", 1 ); /* формируем код ассембле-*/
                    /* ровской операции L     */
                    
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, /*       формируем        */
                            "@R2," );/*       первый  и        */
                    strcat ( ASS_CARD._BUFCARD.OPERAND, /* второй операнды ассемб-*/
                            FORMT [0]);/* леровской операции     */
                    
                    ASS_CARD._BUFCARD.OPERAND [ strlen /* вставляем разделитель  */
                                               ( ASS_CARD._BUFCARD.OPERAND ) ] = ' ';
                    
                 //   memcpy ( ASS_CARD._BUFCARD.COMM, /* и построчный коментарий*/
                   //         "Загрузка переменной в регистр", 29 );
                    
                    ZKARD (); /* запомнить операцию ас- */
                    /* семблера  и            */
                    return 0; /* завершить программу    */
                }
                else
                    return 3; /* если тип терма не bin  */
                /* fixed,то выход по ошиб-*/
                /* ке                     */
            }
        }
        return 4;                         /* если терм-идентификатор*/
        /* неопределен, то выход  */
        /* по ошибке              */
    }
    else                                      /* если правая часть ариф-*/
    /* метического выражения  */
    /* двухтермовая, то:      */
    {
        for ( i = 0; i < ISYM; i++ )      /* если правый терм ариф- */
        {                                 /* метического выражения  */
            if ( !strcmp ( SYM [i].NAME, /*определен в табл.SYM,то:*/
                          FORMT [IFORMT-1] )  &&
                strlen ( SYM [i].NAME ) ==
                strlen ( FORMT [IFORMT-1] )
                )
            {
                
                
                if ( SYM [i].TYPE == 'D' ) {
                    //convert from decimal to binary
                    //L     RRAB,B
                    //ST    RRAB,BUF+5
                    //CVB   R3,BUF
                    
                    /*
                     memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAC, "LH",2 );
                     strcpy ( ASS_CARD._BUFCARD.OPERAND, "R2," );
                     strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT [IFORMT-1] );
                     ZKARD ();
                     */
                    
                    
                    
                    /*
                     memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAC, "L", 1 );
                     //TODO what to do if razr will be set later after initialization?
                     strcpy ( ASS_CARD._BUFCARD.OPERAND, "RRAB," );
                     strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT [IFORMT-1] );
                     strcat ( ASS_CARD._BUFCARD.OPERAND, "\n");
                     ZKARD ();
                     
                     memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAC, "ST",2 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAND, "RRAB,BUF+5", 10 );
                     ZKARD ();*/
                    
                    
                    memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                    memcpy ( ASS_CARD._BUFCARD.OPERAC, "MVC", 3 );
                    //TODO what to do if razr will be set later after initialization?
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, "@BUF+5(3)," );
                    strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT [IFORMT-1] );
                    strcat ( ASS_CARD._BUFCARD.OPERAND, "\n");
                    ZKARD ();
                    
                    
                    
                    memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                    memcpy ( ASS_CARD._BUFCARD.OPERAC, "CVB",3 );
                    memcpy ( ASS_CARD._BUFCARD.OPERAND, "@R3,@BUF", 8 );
                    ZKARD ();
                    /*
                     memcpy ( ASS_CARD._BUFCARD.METKA, "TRUE", 4 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC",2 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAND, "H'1'", 4 );
                     ZKARD ();
                     
                     memcpy ( ASS_CARD._BUFCARD.METKA, "TRUE", 4 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC",2 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAND, "H'1'", 4 );
                     ZKARD ();*/
                    
                    
                    if ( STROKA [ DST [I2].DST4 - /* если же знак операции  */
                                 strlen ( FORMT [IFORMT-1] ) ] == /* арифметического выра-  */
                        '=' )/* жения "=", то:         */
                        
                    {
                        
                        //      LH    RRAB,TRUE
                        //      CR    R2,R3
                        //      BC    7,L2      not equal
                        //      BC    15,L1     unconditional
                        //L2    LH    RRAB,FALSE
                        //L1
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "LH", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAND, "@RRAB,@TRUE", 11 );
                        ZKARD ();
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "CR", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAND, "@R2,@R3", 7 );
                        ZKARD ();
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "BC", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAND, "8,@L1", 5 );
                        ZKARD ();
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "BC", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAND, "15,@L2", 6 );
                        ZKARD ();
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "@L2", 3 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "LH", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAND, "@RRAB,@FALSE", 12 );
                        ZKARD ();
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "@L1", 3 );
                        //memcpy ( ASS_CARD._BUFCARD.OPERAC, "NOP", 3 );
                        //memcpy ( ASS_CARD._BUFCARD.OPERAND, "", 0 );
                        //ZKARD ();
                        
                        
                        
                        
                    } else {
                        
                        //error unsupported operation for decimal fixed
                        return 5;
                    }
                    
                    return 0;
                    
                }
                
                
                
                
                
                if ( SYM [i].TYPE == 'D' || SYM [i].TYPE == 'B' ) /* если тип правого опе-  */
                {           /* ранда bin fixed, то:   */
                    
                    if ( STROKA [ DST [I2].DST4 - /* если знак опер."+",то: */
                                 strlen( FORMT [IFORMT-1] ) ] == '+' )
                    {
                        if ( strcmp ( SYM [i].RAZR, "15" ) /* если разрядность прав. */
                            <= 0 ) /* операнда <= 15, то:    */
                            memcpy ( ASS_CARD._BUFCARD.OPERAC,
                                    "AH", 2 ); /* формируем код ассембле-*/
                        else /* ровской операции "AH",а*/
                            memcpy ( ASS_CARD._BUFCARD.OPERAC,
                                    "A", 1 ); /* иначе - "A"            */
                    }
                    
                    else if ( STROKA [ DST [I2].DST4 - /* если же знак операции  */
                                      strlen ( FORMT [IFORMT-1] ) ] == /* арифметического выра-  */
                             '-' )/* жения "-", то:         */
                        
                    {
                        if ( strcmp ( SYM [i].RAZR, "15" )/* при разрядности ариф-  */
                            <= 0 ) /* метич.выраж.<= 15      */
                            memcpy( ASS_CARD._BUFCARD.OPERAC,/* формируем код ассембле-*/
                                   "SH", 2 ); /* ровской операции "SH",F*/
                        else
                            memcpy( ASS_CARD._BUFCARD.OPERAC,/* иначе - "S"            */
                                   "S", 1 );
                    }
                    
                    else
                    {
                        
                        return 5; /* если знак операции не  */
                        /* "+" и не "-", то завер-*/
                        /* шение  программы  по   */
                        /* ошибке                 */
                    }
                    /* формируем:             */
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, /* - первый операнд ассем-*/
                            "@RRAB," );/*блеровской операции;    */
                    strcat ( ASS_CARD._BUFCARD.OPERAND, /* - второй операнд ассем-*/
                            FORMT [IFORMT-1] );/*блеровской операции;    */
                    ASS_CARD._BUFCARD.OPERAND [ strlen
                                               ( ASS_CARD._BUFCARD.OPERAND )] =/* - разделяющий пробел;  */
                    ' ';
                 //   memcpy ( ASS_CARD._BUFCARD.COMM,
                   //         "Формирование промежуточного значения",/* - построчный коментарий*/
                     //       36 );
                    ZKARD (); /* запоминание ассембле-  */
                    /* ровской операции       */
                    
                    return 0; /* успешное завершение    */
                    /* пограммы               */
                }
                else
                    
                    
                    
                    return 3; /* если тип правого опе-  */
                /* ранда арифметического  */
                /* выражения не bin fixed,*/
                /* то завершение програм- */
                /* мы по ошибке           */
            }
        }
        return 4;                         /* если правый операнд    */
        /* арифметического выраже-*/
        /*ния не определен в табл.*/
        /* SYM, то завершить про- */
        /* грамму по ошибке       */
    }
    
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала BUK на вто-*/
/* ром проходе.   Здесь   */
/* BUK -   "буква"        */

int BUK2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала CIF на вто-*/
/* ром проходе.   Здесь   */
/* CIF -   "цифра"        */

int CIF2 ()
{
    return 0;
}

/*..........................................................................*/


/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IDE на вто-*/
/* ром проходе.   Здесь   */
/* IDE -   "идентификатор"*/

int IDE2 ()
{
    return 0;
}


/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPE на вто-*/
/* ром проходе.   Здесь   */
/* IPE - "имя переменной" */

int IPE2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPR на вто-*/
/* ром проходе.   Здесь   */
/* IPR -   "имя программы" */

int IPR2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала LIT на вто-*/
/* ром проходе.   Здесь   */
/* LIT -   "литерал"      */

int LIT2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала MAN на вто-*/
/* ром проходе.   Здесь   */
/* MAN -   "мантисса"     */

int MAN2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ODC на вто-*/
/* ром проходе.   Здесь   */
/* ODC - "операт.ПЛ1- DCL"*/

int ODC2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OEN на вто-*/
/* ром проходе.   Здесь   */
/* OEN - "операт.ПЛ1-END" */

/* программа    формирует */
/* эпилог ассемблеровского*/
/* эквивалента ПЛ1-прог-  */
/* раммы                  */
int OEN2 ()
{
    char RAB [20];
    char i = 0;
    FORM ();                                  /* форматируем ПЛ1-опера- */
    /* тор END                */
    
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "BCR", 3 ); /* формируем код безуслов-*/
    /*ного возврата управления*/
    /* в вызывающую программу */
    
    memcpy ( ASS_CARD._BUFCARD.OPERAND,"15,14", 5 );/* операнды команды и     */
    
   // memcpy ( ASS_CARD._BUFCARD.COMM,          /* поле построчного комен-*/
     //       "Выход из программы", 18 );/* тария                  */
    
    ZKARD ();                                 /* запомнить опреацию     */
    /* Ассемблера             */
    
    /* далее идет блок форми- */
    /* рования декларативных  */
    /* псевдоопераций DC для  */
    /* каждого идентификатора,*/
    /* попавшего в табл.SYM   */
    
    
    
    //TRUE     DC    H'1'
    memcpy ( ASS_CARD._BUFCARD.METKA, "@TRUE", 5 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC",2 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "H'1'", 4 );
    ZKARD ();
    
    //FALSE    DC    H'0'
    memcpy ( ASS_CARD._BUFCARD.METKA, "@FALSE", 6 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC",2 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "H'0'", 4 );
    ZKARD ();
    
    
    
    for ( i = 0; i < ISYM; i++ )
    {                                         /* если строка табл.SYM   */
        if ( isalpha ( SYM [i].NAME [0] ) ) /* содержит идентификатор,*/
        /* т.е.начинается с буквы,*/
        {   
            printf("%s, %s, %s, %s\n", SYM[i].NAME, SYM[i].TYPE, SYM[i].RAZR, SYM[i].INIT );                              /* то:                    */
            if ( SYM [i].TYPE == 'B' ) /* если тип оператора bin */
            /* fixed, то:             */
            {
                /*
                //reserve bytes before binary (unnessecary in some cases)
                //         DS    0H */
                
                strcpy ( ASS_CARD._BUFCARD.METKA, /* пишем идентификатор в  */
                        SYM [i].NAME ); /* поле метки псевдоопера-*/
                /* ции DC                 */
                ASS_CARD._BUFCARD.METKA [ strlen
                                         ( ASS_CARD._BUFCARD.METKA ) ] = ' '; /* пишем разделитель полей*/
                
                memcpy ( ASS_CARD._BUFCARD.OPERAC, /* пишем код псевдоопера- */
                        "DC", 2 ); /* ции DC                 */
                
                if ( strcmp ( SYM [i].RAZR, "15" ) <= 0 ) /* формируем операнды псе-*/
                /* вдооперации DC         */
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, /* для случая полуслова   */
                            "H\'" );
                else        /* или                    */
                    
                    strcpy ( ASS_CARD._BUFCARD.OPERAND,      /* для случая слова       */ "F\'" );
                
                //Dos command
                //  strcat ( ASS_CARD._BUFCARD.OPERAND,       /* формируем цифровую     */
                //     ltoa ( VALUE (SYM [i].INIT),     /* часть операнда псевдо- */
                //         &RAB [0], 10) ); /* операции,              */
                //let's do that in Unix!
                long int val = VALUE(SYM[i].INIT);
                //printf("%d",val);
                strcat(ASS_CARD._BUFCARD.OPERAND, gcvt(val, 10, &RAB[0]));
                ASS_CARD._BUFCARD.OPERAND [ strlen /* замыкающий апостроф    */
                                           ( ASS_CARD._BUFCARD.OPERAND ) ] = '\''; /*          и             */
                
                //memcpy ( ASS_CARD._BUFCARD.COMM, /* поле построчного комен-*/
                  //      "Определение переменной", 22 ); /* тария                  */
                
                ZKARD ();   /* запомнить операцию     */
                /*    Ассемблера          */
            } else if (SYM[i].TYPE == 'D') {
                strcpy ( ASS_CARD._BUFCARD.METKA, /* пишем идентификатор в  */
                        SYM [i].NAME ); /* поле метки псевдоопера-*/
                /* ции DC                 */
                ASS_CARD._BUFCARD.METKA [ strlen
                                         ( ASS_CARD._BUFCARD.METKA ) ] = ' '; /* пишем разделитель полей*/
                
                memcpy ( ASS_CARD._BUFCARD.OPERAC, /* пишем код псевдоопера- */
                        "DC", 2 ); /* ции DC                 */
                
                strcpy ( ASS_CARD._BUFCARD.OPERAND,      /* для случая слова       */ "PL3\'" );
                
                //Dos command
                //  strcat ( ASS_CARD._BUFCARD.OPERAND,       /* формируем цифровую     */
                //     ltoa ( VALUE (SYM [i].INIT),     /* часть операнда псевдо- */
                //         &RAB [0], 10) ); /* операции,              */
                //let's do that in Unix!
                strcat(ASS_CARD._BUFCARD.OPERAND, gcvt(VALUE(SYM[i].INIT), 10, &RAB[0]));
                ASS_CARD._BUFCARD.OPERAND [ strlen /* замыкающий апостроф    */
                                           ( ASS_CARD._BUFCARD.OPERAND ) ] = '\''; /*          и             */
                
             //   memcpy ( ASS_CARD._BUFCARD.COMM, /* поле построчного комен-*/
               //         "Определение переменной", 22 ); /* тария                  */
                
                ZKARD ();   /* запомнить операцию     */
                
            }
        }
    }
    
    
    //TODO place buf to SUM (declare constant buffers only if nessecary for code)
    
    //         DS    0F
    //BUF      DC    DL8'0'
    memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "DS",2 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "0H", 2 );
    ZKARD ();
    memcpy ( ASS_CARD._BUFCARD.METKA, "@BUF", 4 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC",2 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "PL8'0'", 6 );
    ZKARD ();
    
    
    
    /* далее идет блок декла- */
    /* ративных ассемблеровс- */
    /* ких EQU-операторов, оп-*/
    /* ределяющих базовый и   */
    /* рабочий регистры общего*/
    /* назначения             */
    
    memcpy ( ASS_CARD._BUFCARD.METKA, "@RBASE", 6 ); /* формирование EQU-псев- */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 ); /* дооперации определения */
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "15", 2 ); /* номера базового регист-*/
    /* ра общего назначения   */
    /*           и            */
    ZKARD ();                                 /* запоминание ее         */
    
    memcpy ( ASS_CARD._BUFCARD.METKA, "@RRAB", 5 ); /* формирование EQU-псев- */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 ); /* дооперации определения */
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "4", 1 ); /* номера базового регист-*/
    /* ра общего назначения   */
    /*            и           */
    ZKARD ();                                 /* запоминание ее         */\
    
    memcpy ( ASS_CARD._BUFCARD.METKA, "@R2", 3 ); /* формирование EQU-псев- */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 ); /* дооперации определения */
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "2", 1 ); /* номера базового регист-*/
    /* ра общего назначения   */
    /*            и           */
    ZKARD ();                                 /* запоминание ее         */
    
    memcpy ( ASS_CARD._BUFCARD.METKA, "@R3", 3 ); /* формирование EQU-псев- */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 ); /* дооперации определения */
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "3", 1 ); /* номера базового регист-*/
    /* ра общего назначения   */
    /*            и           */
    ZKARD ();                                 /* запоминание ее         */
    
    
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "END", 3 ); /* формирование кода ас-  */
    /* семблеровской псевдо-  */
    /* операции END,          */
    i = 0;
    
    while ( FORMT [1][i] != '\x0' )           /* ее операнда            */
        ASS_CARD._BUFCARD.OPERAND [i] = FORMT [1][i++]; /*         и              */
    
   // memcpy ( ASS_CARD._BUFCARD.COMM,          /* построчного коментария */
     //       "Конец программы", 15 );
    
    ZKARD ();                                 /* запоминание псевдоопе- */
    /* рации                  */
    
    return 0;                                 /* завершение программы   */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OPA на вто-*/
/* ром проходе.   Здесь   */
/* OPA - "операт.присваи- */
/* вания арифметический   */

int OPA2 ()
{
    int i;
    
    FORM ();                                  /*форматируем ПЛ1-оператор*/
    /*присваивания арифметич. */
    
    for ( i = 0; i < ISYM; i++ )
    {                                         /* если идентификатор пра-*/
        /* вой части оператора оп-*/
        if ( !strcmp ( SYM [i].NAME, FORMT [0] )  &&/* ределен ранее через    */
            strlen ( SYM [i].NAME ) == /* оператор DCL, то:      */
            strlen ( FORMT [0] )
            )
        {
            if ( SYM [i].TYPE == 'B' ) /* если этот идентификатор*/
            {                   /* имеет тип bin fixed,то:*/
                
                if ( strcmp ( SYM [i].RAZR, "15" ) /* если bin fixed (15),то:*/
                    <= 0 )
                    memcpy ( ASS_CARD._BUFCARD.OPERAC, /* сформировать команду   */
                            "STH", 3 ); /* записи полуслова       */
                
                else        /* иначе:                 */
                    memcpy ( ASS_CARD._BUFCARD.OPERAC, /* команду записи слова   */
                            "ST", 2 );
                
                strcpy ( ASS_CARD._BUFCARD.OPERAND, /*       доформировать    */
                        "@RRAB," );/*          операнды      */
                
                strcat ( ASS_CARD._BUFCARD.OPERAND, /*           команды      */
                        FORMT [0]);
                ASS_CARD._BUFCARD.OPERAND [ strlen /*              и         */
                                           ( ASS_CARD._BUFCARD.OPERAND ) ] = ' ';
                
         //       memcpy ( ASS_CARD._BUFCARD.COMM, /* построчный коментарий  */
           //             "Формирование значения арифм.выражения",
             //           37 );
                ZKARD ();   /* запомнить операцию     */
                /* Ассемблера  и          */
                return 0;   /* завершить программу    */
            }
            
            else                /* если идентификатор не  */
            /* имеет тип bin fixed,то:*/
                return 3;   /* завершение с диагности-*/
            /* кой ошибки             */
        }
    }
    return 4;                                 /* если идентификатор ра- */
    /* нее не определен через */
    /* ПЛ1-оператор DCL,то за-*/
    /* вершение с диагностикой*/
    /* ошибки                 */
    
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OPR на вто-*/
/* ром проходе.   Здесь   */
/* OPR - "операт.ПЛ1-PROC"*/

/* программа    формирует */
/* пролог ассемблеровского*/
/* эквивалента  исходной  */
/* ПЛ1-программы          */
int OPR2 ()
{
    char i = 0;
    FORM ();                                  /* форматируем оператор   */
    /* ПЛ1 - "начало процедур-*/
    /* ного блока"            */
    while ( FORMT [0][i] != '\x0' )
        ASS_CARD._BUFCARD.METKA [i++] = FORMT [0][i]; /* нулевой терм используем*/
    /* как метку в START-псев-*/
    /* дооперации Ассемблера  */
    
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "START", 5 );/* достраиваем код и опе- */
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "0", 1 ); /* ранды  в  START-псевдо-*/
   // memcpy ( ASS_CARD._BUFCARD.COMM,          /* операции Ассемблера    */
     //       "Начало программы", 16 );
    ZKARD ();                                 /* запоминаем карту Ассем-*/
    /* блера                  */
    
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "BALR", 4 ); /* формируем BALR-операцию*/
    memcpy ( ASS_CARD._BUFCARD.OPERAND,       /* Ассемблера             */
            "@RBASE,0", 8 );
  //  memcpy ( ASS_CARD._BUFCARD.COMM,
    //        "Загрузить регистр базы", 22 );
    ZKARD ();                                 /* и запоминаем ее        */
    
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "USING", 5 );/* формируем USING-псевдо-*/
    memcpy ( ASS_CARD._BUFCARD.OPERAND,       /* операцию Ассемблера    */
            "*,@RBASE", 8 );
  //  memcpy ( ASS_CARD._BUFCARD.COMM,
    //        "Назначить регистр базой", 23 );
    ZKARD ();                                 /* и запоминаем ее        */
    
    return 0;                                 /* завершить подпрограмму */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала PRO на вто-*/
/* ром проходе.   Здесь   */
/* PRO - "программа"      */

int PRO2 ()                                       /*прогр.формирует выходной*/
{                                                 /*файл                    */
    
    FILE *fp;                                 /*набор                   */
    /*рабочих                 */
    /*переменных              */
    
    strcat ( NFIL, "ass" );                   /*сформировать имя выход- */
    /*ного файла              */
    
    if ( (fp = fopen ( NFIL, "wt" )) == NULL ) /*при неудачн.открыт.ф-ла */
        return (7);                       /* сообщение об ошибке    */
    
    else {
                    printf("RF\n");
                                                        /*иначе:                  */
        //fwrite (ASSTXT, 80, IASSTXT, fp); /* формируем тело об.файла*/
        
        for(int assi=0;assi<MAXLTXT;assi++)
        {
            printf("RF\n");
            ASSTXT[assi][78]='\n';
            fprintf(fp, "%s",ASSTXT[assi]);
            printf("%s",ASSTXT[assi]);
        }
}
    fclose ( fp );                            /*закрываем об'ектный файл*/
    return ( 0 );                             /*завершить полдпрограмму */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала RZR на вто-*/
/* ром проходе.   Здесь   */
/* RZR - "разрядность"    */

int RZR2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала TEL на вто-*/
/* ром проходе.   Здесь   */
/* TEL - "тело программы" */

int TEL2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на вто-*/
/* ром проходе.   Здесь   */
/* ZNK - "знак операции"  */

int ZNK2 ()
{
    return 0;
}

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на вто-*/
/* ром проходе.   Здесь   */
/* ZNK - "знак операции"  */

int DCF2 ()
{
    return 0;
}

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на вто-*/
/* ром проходе.   Здесь   */
/* ZNK - "знак операции"  */

int LOP2 ()
{
    return 0;
}

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на вто-*/
/* ром проходе.   Здесь   */
/* ZNK - "знак операции"  */

int LOG2 ()
{
    return 0;
}

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на вто-*/
/* ром проходе.   Здесь   */
/* ZNK - "знак операции"  */

int OPL2 ()
{
    return 0;
}

/*..........................................................................*/

/*  п р о г р а м м а     */
/* управления абстрактной */
/* ЭВМ  -  семантического */
/* вычислителя, интерпре- */
/* тирующего абстрактную  */
/* программу, сформирован-*/
/* ную синтаксическим ана-*/
/* лизатором в стеке дос- */
/* тигнутых целей.        */

/* Суть алгоритма управле-*/
/*ния  в  последовательной*/
int gen_COD ()                                    /*интерпретации строк сте-*/
{                                                 /*ка достижений  в направ-*/
    int NOSH;                                 /*лении от дна к вершине. */
    
    int (*FUN [NNETRM][2]) () =               /*При этом каждая строка  */
    {                                         /*воспринимается как кома-*/
        { /*    1  */ AVI1, AVI2 },       /*нда абстрактной ЭВМ со  */
        { /*    2  */ BUK1, BUK2 },       /*следующими полями:      */
        { /*    3  */ CIF1, CIF2 },
        { /*    4  */ IDE1, IDE2 }, /* - DST.DST1 - код опера-*/
        { /*    5  */ IPE1, IPE2 }, /*ции;                    */
        { /*    6  */ IPR1, IPR2 },
        { /*    7  */ LIT1, LIT2 },       /* - DST.DST2 - левая гра-*/
        { /*    8  */ MAN1, MAN2 }, /*ница интерпретируемого  */
        { /*    9  */ ODC1, ODC2 }, /*фрагмента исх.текста;   */
        { /*   10  */ OEN1, OEN2 },
        { /*   11  */ OPA1, OPA2 }, /* - DST.DST4 -правая гра-*/
        { /*   12  */ OPR1, OPR2 }, /*ница интерпретируемого  */
        { /*   13  */ PRO1, PRO2 }, /*фрагмента исх.текста.   */
        { /*   14  */ RZR1, RZR2 },
        { /*   15  */ TEL1, TEL2 },
        { /*   16  */ ZNK1, ZNK2 },
        { /*   17  */ DCF1, DCF2 },
        { /*   17  */ LOP1, LOP2 },
        { /*   17  */ LOG1, LOG2 },
        { /*   17  */ OPL1, OPL2 }
    };
    
    for ( I2 = 0; I2 < L; I2++ )              /* организация первого    */
        if ( ( NOSH = FUN [               /* прохода семантического */
                           numb ( DST [I2].DST1, 3 ) /* вычисления             */
                           ][0] ()
              ) != 0
            )
            return (NOSH);            /* выход из программы     */
    /* по ошибке              */
    
    for ( I2 = 0; I2 < L; I2++ )              /* организация второго    */
        if ( ( NOSH = FUN [               /* прохода семантического */
                           numb ( DST [I2].DST1, 3 ) /* вычисления             */
                           ][1] ()
              ) != 0
            )
            return (NOSH);            /* выход из программы     */
    /* по ошибке              */
    
    return 0;                                 /* успешное завершение    */
    /* программы              */
}

/*..........................................................................*/

/*  п р о г р а м м а,    */
/* организующая последова-*/
/* тельную обработку ис-  */
/* ходного текста:        */
/* - лексич.анализатором; */
/* - синтаксич.анализат.; */
/* - семантич.вычислителем*/
int main (int argc, char **argv )
{                                                 /* рабочие переменные:    */
    FILE *fp;                                 /* - указатель на файл;   */
    char *ptr=argv[1];                        /* - указатель на первый  */
    /*параметр командной стр. */
    
    system("pwd");
    
    strcpy ( NFIL, ptr );                     /*изъять имя транслируемой*/
    /*программы из командной  */
    /*строки в рабочее поле   */
    
    /*проверяем корректность  */
    /*командной строки        */
    if ( argc != 2 )
        
    {                                         /* по ошибке в командн.стр*/
        printf ("%s\n", "Ошибка в командной строке"); /* выдать диагностику и   */
        return 1;                           /* завершить трансляцию   */
    }
    
    /* проверка типа исх.файла*/
    if
        (
	        strcmp ( &NFIL [ strlen ( NFIL )-3 ], "pli" ) /* если тип не "pli", то: */
         )
        
    {
        printf ( "%s\n",                  /* выдать диагностику и   */
                "Неверный тип файла с исходным текстом" );
        return 1;                           /* завершить трансляцию   */
    }
    
    
    else                                      /* если тип файла "pli",то*/
        
    {                                         /*пытаемся открыть файл и */
        if ( (fp = fopen ( NFIL, "rb" )) == NULL ) /*при неудачн.открыт.ф-ла */
        /* сообщение об ошибке и  */
        {
            printf ( "%s\n",
                    "Не найден файл с исходным текстом" );
            return 1;                   /* завершение трансляции  */
        }
        
        else                              /* иначе:                 */
        /* пишем файл в массив    */
        /*  ISXTXT                */
        {
            for ( NISXTXT = 0; NISXTXT <= MAXNISXTXT; NISXTXT++ )
            {
                memset(ISXTXT[NISXTXT], 0, 80*sizeof(char));
                if ( fgets(ISXTXT[NISXTXT], 80, fp) == NULL )//!fread ( ISXTXT [NISXTXT], 80, 1, fp ) )
                {
                    if ( feof ( fp ) ) /* в конце файла идем на  */
                        goto main1; /* метку  main1           */
                    else          /* при сбое чтения        */
                    {            /* выдаем диагностику     */
                        printf ( "%s\n",
                                "Ошибка при чтении фыйла с исх.текстом" );
                        return 1; /* и завершаем трансляцию */
                    }
                }
                for (int i=0; i<strlen(ISXTXT[NISXTXT]); i++)
                {
                    if(ISXTXT[NISXTXT][i]=='\n')
                        ISXTXT[NISXTXT][i]=0;
                }
            }
            
            printf ( "%s\n",          /*при пеерполнении массива*/
                    "Переполнение буфера чтения исх.текста" ); /* ISXTXT выдать диагн.   */
            return 1;                   /* и завершить трансляцию */
        }
        
    }
    
main1:                                            /* по завершении чтения   */
    /* исх.файла формируем    */
    fclose ( fp );                            /* префикс имени выходного*/
    NFIL [ strlen ( NFIL )-3 ] = '\x0';       /* Ассемблеровского файла */
    
    memset ( ASS_CARD.BUFCARD, ' ', 80 );     /* чистка буфера строки   */
    /* выходного ассемблеров- */
    /* ского файла            */
    
    compress_ISXTXT ();                       /* лексический анализ     */
    /* исходного текста       */
    
    build_TPR ();                             /* построение матрицы     */
    /* преемников             */
    
    if ( (sint_ANAL ()) )                     /* синтаксический анализ  */
    {                                         /* исходного текста       */
        STROKA [I4 +20] = '\x0';
        printf                            /* если найдены ошибки    */
        (                         /* синтаксиса, то :       */
         "%s%s%s%s\n",
         "ошибка синтаксиса в исх.тексте -> ", /* выдаем диагностику и   */
         "\"...",&STROKA [I4], "...\""
         );
        printf
        (
         "%s\n", "трансляция прервана"
         );
        return 1;                           /* завершаем трансляцию   */
    }
    else                                      /* иначе делаем           */
    {
        switch ( gen_COD () )             /* семантическое вычислен.*/
        {
            case  0:                          /*если код завершения = 0,*/
                /* то:                    */
                
                printf ( "%s\n",          /* - диагностич.сообщение;*/
                        "трансляция завершена успешно" );
                return 1;                   /* - завершить трансляцию */
                
                
            case  1:                          /*если код завершения = 1,*/
                /* то:                    */
                printf ( "%s\n",          /* - диагностич.сообщение;*/
                        "несовпадение имени процедуры в прологе-эпилоге" );
                break;                    /* - выйти на обобщающую  *//* - диагностич.сообщение;*/
                /*диагностику             */
                
            case  2:                          /*если код завершения = 2,*/
                /* то:                    */
                STROKA [ DST [I2].DST2 +20 ] = '\x0'; /* - диагностич.сообщение;*/
                printf ( "%s%s\n%s%s%s\n",
                        "недопустимый тип идентификатора: ",
                        &FORMT [1], " в исх.тексте -> \"...",
                        &STROKA [ DST [I2].DST2 ], "...\"" );
                break;                    /* - выйти на обобщающую  */
                /*диагностику             */
                
            case  3:                          /*если код завершения = 3,*/
                /* то:                    */
                STROKA [ DST [I2].DST2 + 20 ] = '\x0'; /* - диагностич.сообщение;*/
                printf ( "%s%s\n%s%s%s\n",
                        "недопустимый тип идентификатора: ",
                        &FORMT [IFORMT-1], " в исх.тексте -> \"...",
                        &STROKA [ DST [I2].DST2 ], "...\"" );
                break;                    /* -выйти на обобщающую   */
                /*диагностику             */
                
            case  4:                          /*если код завершения = 4,*/
                /* то:                    */
                STROKA [ DST [I2].DST2 + 20 ] = '\x0'; /* - диагностич.сообщение;*/
                printf ( "%s%s\n%s%s%s\n",
                        "неопределенный идентификатор: ",
                        &FORMT [IFORMT-1], " в исх.тексте -> \"...",
                        &STROKA [ DST [I2].DST2 ], "...\"" );
                break;                    /* - выйти на обобщающую  */
                /*диагностику             */
                
            case  5:                          /*если код завершения = 5,*/
                /* то:                    */
                STROKA [ DST [I2].DST2 + 20 ] = '\x0'; /* - диагностич.сообщение;*/
                printf ( "%s%c\n%s%s%s\n",
                        "недопустимая операция: ",
                        STROKA [ DST [I2].DST4 - strlen ( FORMT [IFORMT-1] ) ],
                        " в исх.тексте -> \"...", &STROKA [ DST [I2].DST2 ], "...\"");
                break;                    /* - выйти на обобщающую  */
                /*диагностику             */
                
            case  6:                          /*если код завершения = 6 */
                /* то:                    */
                STROKA [ DST [I2].DST2 + 20 ] = '\x0'; /* - диагностич.сообщение;*/
                printf ( "%s%s\n%s%s%s\n",
                        "повторное объявление идентификатора: ",
                        &FORMT [1], " в исх.тексте -> \"...",
                        &STROKA [ DST [I2].DST2 ], "...\"" );
                break;                    /* - выйти на обобщающую  */
                /*диагностику             */
                
        }
        
    }
    
    printf ( "%s\n", "трансляция прервана" ); /* обобщающая диагностика */
    return 0;
}
/*..........................................................................*/
